@Value 可以读取yml中的数值

redis五中数据结构 list hash set zset String

final修饰的方法可以被继承（不能被重写），但是可以被重载。（final修饰的方法可以被继承和重载）
final可用于声明属性、方法和类，分别表示属性不可变，方法不可重写，类不可继承。

第一范式，列原子性，第二范式，非主键属性完全依赖于主键，第三范式消除传递依赖

Java八大数据类型：
（1）整数类型：short、int、long、byte<——字节
（2）小数类型：float、double
（3）字符类型：char
（4）布尔类型：boolean

如果有两个类A和B，B继承了A，A和B里面都有静态方法和静态变量，那么它的类加载过程是怎么样的呢？（不是JVM级别）
1、父类的静态变量
2、父类的静态代码块
3、子类的静态变量
4、子类的静态代码块
5、父类的非静态变量
6、父类的非静态代码块
7、父类的构造方法  <————————重点~
8、子类的非静态变量
9、子类的非静态代码块
10、子类的构造方法

最左匹配原则：
联合索引的最左前缀匹配指的是where条件一定要有联合索引的第一个字段
是否走联合索引与where条件的顺序无关，只与字段有关

当你不再需要该表时， 用 drop；
当你仍要保留该表，但要删除所有记录时， 用 truncate；
当你要删除部分记录时（always with a WHERE clause), 用 delete.

“HashMap对象的key、value值均可为null
如果添加两个key相同的键值对,则后面的value会覆盖前面的value。”
“set可以存储null ”

一丶存放
List存放元素是有序，可重复
Set存放元素无序，不可重复
Map元素键值对形式存放，键无序不可重复，值可重复
二丶取出
List取出元素for循环，foreach循环，Iterator迭代器迭代
Set取出元素foreach循环，Iterator迭代器迭代
Map取出元素需转换为Set，然后进行Iterator迭代器迭代，或转换为Entry对象进行Iterator迭代器迭代

Integer和int的区别。
原因是： 当我们使用Integer 去接收时是可以接收到 null 值的，这样就可以避免出现空指针。
Integer的默认值是null，int的默认值是0

索引种类
普通索引：仅加速查询
唯一索引：加速查询 + 列值唯一（可以有null）
主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
全文索引：对文本的内容进行分词，进行搜索

@Controller和@RestController的区别
@RestController等于@ResponseBody+@Controller

静态内部类使用场景一般是当外部类需要使用内部类，而内部类无需外部类资源，并且内部类可以单独创建的时候会考虑采用静态内部类的设计。
需要注意的是当一个内部类没有使用static修饰的时候，是不能直接使用内部类创建对象，须要先使用外部类对象点new内部类对象及(外部类对象.new 内部类（）)
如果没有用static修饰InterClass，则只能按如下方式调用：需要先new 一个外部类实例
OuterClass oc = new OuterClass(); 在使用外部类实例点内部类实例
oc.new InnerClass();


 GC roots对象包括：
虚拟机栈中（栈帧中的局部变量表）引用的变量
本地方法栈中（Native方法）引用的变量
方法区中的常量引用的对象
方法区中的类静态属性引用的对象


程序计数器、虚拟机栈和本地方法栈都是线程私有的，随着线程的出生而出生，随着线程的死亡而死亡。它们是不存在垃圾回收的，更何况虚拟机栈时刻发生着入栈出栈的操作，基本很少会出现栈内存溢出的问题。所以这里我们的垃圾回收发生在堆和方法区这两个线程共享的区域。值的一提的是，很多人都认为方法区不会被垃圾回收，其实不然，方法区也会被垃圾回收，其中的一些废弃的常量啊和不再使用的类型都可能被回收，不过它们被回收的收益不高，而且jvm规范提到过可以不实现方法区的垃圾回收，所以这里我们就不对方法区展开讲，把注意力集中到我们的堆上。

没有被变量引用的对象就是垃圾，需要被回收。有两种方法判断对象有没有被引用：引用计数法和可达性分析

代理模式：
代理是一种设计模式，在开发中当我们要访问目标类的时候，不是直接访问目标类，而是先调用其代理类，通过代理类调用目标类来完成操作，简单来说就是直接调用变成了间接调用，那这样做最大的好处就是我们可以在代理类调用目标类之前或之后去添加一些预处理和后处理的操作，来扩展一些不属于目标类的功能。


总的流程：一个请求过来时通过各个过滤器，最后通过FilterSecurityInterceptor来判断这个请求url是否是不需要验证的，如果是就直接访问到我们的接口api，如果不是的话，再判断当前请求线程中是否有authentication的认证对象，如果有就放行，如果没有就返回登录页面（比如这里我们设置的是登录表单的方式），来到登录页面输入账号密码登录后就会来到    UsernamePasswordAuthenticationFilter，经过一系列的操作，最后验证成功就会把认证对象authentication放进securityContext中，然后FilterSecurityInterceptor判断到当前请求线程中这个认证对象就放行，返回的时候最后会通过securityContextpersistenceFilter，判断当前线程是否有securityContext，如果有就放进session，那么下次再请求这个url的时候会首先通过securityContextpersistenceFilter这个过滤器，判断session中是否有securityContextduxiiang，如果有就放进当前请求线程中，然后最后经过FilterSecurityInterceptor时再判断当前请求线程是否有认证对象，由于最前面经过securityContextpersistenceFilter，已经从session中把认证对象放进了当前请求线程中，所以FilterSecurityInterceptor会直接放行，这样就访问到我们的接口api。


死锁产生的4个必要条件
    1、互斥： 某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
    2、占有且等待： 一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
    3、不可抢占： 别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
    4、循环等待： 存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。
        当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。那么，解决死锁问题就是相当有必要的了。
